{% extends "base/base.html" %}

{% block title %}Add Athletes{% endblock %}

{% block extra_head %}
    <meta charset="UTF-8">
    <title>Hawkin Dynamics Data</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/13.2.0/math.js"></script>
    <link rel="stylesheet" href="{{ url_for('static', filename='hawkin.css') }}">
{% endblock %}
{% block content %}
    <div class="chart-container">
        <div class="chart-title">Hawkin Dynamics Data</div>
        
        <!-- Dropdown to select the stat to visualize -->
        <label for="statSelect" class="stat-label">Select Stat:</label>
        <select id="statSelect">
            <option value="">Select Stat</option>
            <!-- Options will be added dynamically in JavaScript -->
        </select>

        <!-- Time Range Selectors -->
        <div class="time-scale-container">
            <label for="startDate" class="time-label">Start Date:</label>
            <input type="date" id="startDate" class="time-input">
            <label for="endDate" class="time-label">End Date:</label>
            <input type="date" id="endDate" class="time-input">
        </div>

        <label for="toggleRegression" class="toggle-label">
            Show Regression Line:
            <input type="checkbox" id="toggleRegression" class="toggle-checkbox">
            <span class="toggle-slider"></span>
        </label>
        
        <!-- Canvas for Chart.js -->
        <canvas id="statChart" width="600" height="400"></canvas>
        <div class="time-filter-buttons">
            <button class="btn" data-time="week">Last Week</button>
            <button class="btn" data-time="month">Last Month</button>
            <button class="btn" data-time="year">Last Year</button>
            <button class="btn active" data-time="all">All Time</button>
        </div>
    </div>
{% endblock %}

{% block extra_js %}
    <script>
        const athleteData = JSON.parse('{{ athlete_data | safe }}');

        const ignoreKeys = ["id", "athlete_id", "athlete_name", "athlete_teams", "athlete_groups", "athlete_active", "testType_id", "testType_name", "testType_canonicalId", "tag_ids", "tag_names", "segment", "active", "timestamp"];

        // Extract unique stat keys
        const statKeys = Object.keys(athleteData[0]).filter(key => !ignoreKeys.includes(key));
        const statSelect = document.getElementById("statSelect");
        const startDate = document.getElementById("startDate");
        const endDate = document.getElementById("endDate");

        // Set the default start and end dates to the first and last test dates
        const firstTestDate = new Date(athleteData[athleteData.length - 1].timestamp * 1000).toISOString().split("T")[0];
        const lastTestDate = new Date(athleteData[0].timestamp * 1000).toISOString().split("T")[0];
        startDate.value = lastTestDate;
        endDate.value = firstTestDate;
        
        // Populate the dropdown options
        statKeys.forEach(stat => {
            const option = document.createElement("option");
            option.value = stat;
            option.textContent = stat;
            statSelect.appendChild(option);
        });

        // Set up Chart.js
        const ctx = document.getElementById("statChart").getContext("2d");
        const statChart = new Chart(ctx, {
            type: "scatter",
            data: {
                datasets: [{
                    label: "Stat over Time",
                    data: [],
                    borderColor: "blue",
                    backgroundColor: "rgba(0,0,255,0.1)"
                }]
            },
            options: {
                scales: {
                    x: {
                        type: "time",
                        time: {
                            unit: "day"
                        },
                        title: {
                            display: true,
                            text: "Time"
                        }
                    },
                    y: {
                        title: {
                            display: true,
                            text: "Stat Value"
                        }
                    }
                }
            }
        });

        // Function to calculate polynomial regression
        function polynomialRegression(x, y, order) {
            // Create the X matrix
            const xMatrix = [];
            for (let i = 0; i < x.length; i++) {
                const row = [];
                for (let j = 0; j <= order; j++) {
                    row.push(Math.pow(x[i], j));
                }
                xMatrix.push(row);
            }

            // Convert arrays to math.js matrices
            const X = math.matrix(xMatrix);
            const Y = math.matrix(y.map(v => [v]));

            // Compute (Xt * X)⁻¹ * Xt * Y to get the coefficients
            const Xt = math.transpose(X);
            const XtX = math.multiply(Xt, X);
            const XtX_inv = math.inv(XtX);
            const XtY = math.multiply(Xt, Y);
            const coefficients = math.multiply(XtX_inv, XtY);

            // Convert to an array for easier access
            const coefficientsArray = coefficients.toArray();

            // Create a predict function based on the calculated coefficients
            return {
                predict: (xVal) => {
                    let yVal = 0;
                    for (let i = 0; i < coefficientsArray.length; i++) {
                        yVal += coefficientsArray[i][0] * Math.pow(xVal, i);
                    }
                    return yVal;
                }
            };
        }

        function generatePolynomialRegression(data, order, minTimestamp, maxTimestamp) {
            const x = data.map(point => point.x);
            const y = data.map(point => point.y);

            // Calculate the polynomial regression
            const regression = polynomialRegression(x, y, order);

            const regressionPoints = [];
            for (let timestamp = minTimestamp; timestamp <= maxTimestamp; timestamp += 86400000) {
                const xValue = (timestamp - minTimestamp) / 86400000; // Normalize x value to range [0, 1]
                const yValue = regression.predict(xValue);
                regressionPoints.push({
                    x: new Date(timestamp),
                    y: yValue
                });
            }
            return regressionPoints;
        }

        // Function to add or remove the regression line based on checkbox
        function toggleRegression(stat) {
            const checkbox = document.getElementById("toggleRegression");
            const regressionDatasetIndex = statChart.data.datasets.findIndex(ds => ds.label.includes("Regression Line"));
            const minTimestamp = statChart.data.datasets[0].data[0].x.getTime();
            const maxTimestamp = statChart.data.datasets[0].data[statChart.data.datasets[0].data.length - 1].x.getTime();

            if (checkbox.checked) {
                //check if regression line already exists then remove it
                if (regressionDatasetIndex !== -1) {
                    statChart.data.datasets.splice(regressionDatasetIndex, 1);
                }

                const data = statChart.data.datasets[0].data;
                const cleanedData = [];
                for (let i = 0; i < data.length; i++) {
                    if (data[i].y !== null) {
                        cleanedData.push({
                            x: (data[i].x.getTime() - minTimestamp) / 86400000, // Normalize x value to range [0, 1]
                            y: data[i].y
                        });
                    }
                }
                
                const regressionPoints = generatePolynomialRegression(cleanedData, 4, minTimestamp, maxTimestamp);
                
                // Add regression line as a new dataset
                statChart.data.datasets.push({
                    label: `${stat} Regression Line`,
                    data: regressionPoints,
                    type: 'line',
                    borderColor: 'red',
                    borderWidth: 2,
                    fill: false,
                    pointRadius: 0
                });
            } else if (!checkbox.checked && regressionDatasetIndex !== -1) {
                // Remove the regression line dataset if it exists
                statChart.data.datasets.splice(regressionDatasetIndex, 1);
            }

            statChart.update();
        }

        // Modify updateChart to call toggleRegression
        function updateChart(stat) {
            const startDate = new Date(document.getElementById("startDate").value).getTime();
            const endDate = new Date(document.getElementById("endDate").value).getTime();

            if (stat === "null") {
                stat = statChart.data.datasets[0].label;
            }

            const data = athleteData
                .filter(test => {
                    const testDate = test.timestamp * 1000;
                    return (!isNaN(startDate) ? testDate >= startDate : true) && 
                        (!isNaN(endDate) ? testDate <= endDate : true);
                })
                .map(test => ({
                    x: new Date(test.timestamp * 1000),
                    y: test[stat]
                }));

            if (data.length === 0) {
                alert("No data available for the selected date range.");
                return;
            }

            statChart.data.datasets[0].data = data;
            statChart.data.datasets[0].label = stat;
            statChart.update();

            // Toggle regression line based on checkbox state
            toggleRegression(stat);
        }

        // Event listener for stat selection
        statSelect.addEventListener("change", (event) => {
            const selectedStat = event.target.value;
            if (selectedStat) {
                updateChart(selectedStat);
            }
        });

        startDate.addEventListener("change", () => {
            if (statSelect.value) updateChart(statSelect.value);
        });

        endDate.addEventListener("change", () => {
            if (statSelect.value) updateChart(statSelect.value);
        });

        // Event listener for checkbox
        document.getElementById("toggleRegression").addEventListener("change", () => {
            if (statSelect.value) toggleRegression(statSelect.value);
        });

        document.querySelectorAll('.time-filter-buttons .btn').forEach(button => {
            button.addEventListener('click', () => {
                const timeRange = button.getAttribute('data-time');
                const endDate = new Date();
                let startDate;

                switch (timeRange) {
                    case 'week':
                        startDate = new Date();
                        startDate.setDate(endDate.getDate() - 7);
                        break;
                    case 'month':
                        startDate = new Date();
                        startDate.setMonth(endDate.getMonth() - 1);
                        break;
                    case 'year':
                        startDate = new Date();
                        startDate.setFullYear(endDate.getFullYear() - 1);
                        break;
                    case 'all':
                        startDate = new Date(athleteData[0].timestamp * 1000);
                        break;
                }

                // Set the date inputs (if you want to show them)
                if (startDate) {
                    document.getElementById('startDate').value = startDate.toISOString().split('T')[0];
                }
                document.getElementById('endDate').value = endDate.toISOString().split('T')[0];

                updateChart('null');
            });
        });

    </script>
{% endblock %}