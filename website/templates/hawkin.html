{% extends "base/base.html" %}

{% block title %}Hawkin Dynamics Data{% endblock %}

{% block extra_head %}
    <meta charset="UTF-8">
    <title>Hawkin Dynamics Data</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/13.2.0/math.js"></script>
    <link rel="stylesheet" href="{{ url_for('static', filename='hawkin.css') }}">
{% endblock %}

{% block content %}
    <div class="chart-container">
        <div class="chart-title">Hawkin Dynamics Data</div>

        {% if user_type == "coach" %}
            <!-- Coach's dropdown to select an athlete -->
            <label for="athleteSelect" class="stat-label">Select Athlete:</label>
            <select id="athleteSelect">
                <option value="">Select Athlete</option>
            </select>
        {% elif user_type == "admin" or user_type == "super_admin" %}
            <!-- Admin's and Super_Admin's dropdowns to select a team and then an athlete -->
            <label for="teamSelect" class="stat-label">Select Team:</label>
            <select id="teamSelect">
                <option value="">Select Team</option>
            </select>
            <label for="athleteSelect" class="stat-label">Select Athlete:</label>
            <select id="athleteSelect">
                <option value="">Select Athlete</option>
            </select>
        {% endif %}
        
        <!-- Dropdown to select the stat to visualize -->
        <label for="statSelect" class="stat-label">Select Stat:</label>
        <select id="statSelect">
            <option value="">Select Stat</option>
            <!-- Options will be added dynamically in JavaScript -->
        </select>

        <!-- Time Range Selectors -->
        <div class="time-scale-container">
            <label for="startDate" class="time-label">Start Date:</label>
            <input type="date" id="startDate" class="time-input">
            <label for="endDate" class="time-label">End Date:</label>
            <input type="date" id="endDate" class="time-input">
        </div>

        <label for="toggleRegression" class="toggle-label">
            Show Regression Line:
            <input type="checkbox" id="toggleRegression" class="toggle-checkbox">
            <span class="toggle-slider"></span>
        </label>
        
        <!-- Canvas for Chart.js -->
        <canvas id="statChart" width="600" height="400"></canvas>
        <div class="time-filter-buttons">
            <button class="btn" data-time="week">Last Week</button>
            <button class="btn" data-time="month">Last Month</button>
            <button class="btn" data-time="year">Last Year</button>
            <button class="btn active" data-time="all">All Time</button>
        </div>
    </div>
{% endblock %}

{% block extra_js %}
    <script>
        let athleteData = JSON.parse('{{ athlete_data | safe }}');

        const userType = '{{ user_type }}';
        const PRESENTATION_MODE = '{{ PRESENTATION_MODE }}';

        const statSelect = document.getElementById("statSelect");
        const athleteSelect = document.getElementById("athleteSelect");
        const teamSelect = document.getElementById("teamSelect");
        
        let selectedAthleteData = [];

        function loadStatOptions(data) {
            const ignoreKeys = ["id", "athlete_id", "athlete_name", "athlete_teams", "athlete_groups", "athlete_active", "testType_id", "testType_name", "testType_canonicalId", "tag_ids", "tag_names", "segment", "active", "timestamp"];
            let statKeys = Object.keys(data[0]).filter(key => !ignoreKeys.includes(key));
            //ingnore any key that starts with external
            statKeys = statKeys.filter(key => !key.startsWith("external"));
            statSelect.innerHTML = '<option value="">Select Stat</option>';
            statKeys.forEach(stat => {
                const option = document.createElement("option");
                option.value = stat;
                option.textContent = stat;
                statSelect.appendChild(option);
            });
        }

        const startDate = document.getElementById("startDate");
        const endDate = document.getElementById("endDate");

        // Set the default start and end dates to the first and last test dates

        function getMinMaxTimestamp() {
            const firstTestDate = new Date(selectedAthleteData[selectedAthleteData.length - 1].timestamp * 1000).toISOString().split("T")[0];
            const lastTestDate = new Date(selectedAthleteData[0].timestamp * 1000).toISOString().split("T")[0];
            startDate.value = lastTestDate;
            endDate.value = firstTestDate;
        }
        
        // Set up Chart.js
        const ctx = document.getElementById("statChart").getContext("2d");
        const statChart = new Chart(ctx, {
            type: "scatter",
            data: {
                datasets: [{
                    label: "Stat over Time",
                    data: [],
                    borderColor: "blue",
                    backgroundColor: "rgba(0,0,255,0.1)"
                }]
            },
            options: {
                scales: {
                    x: {
                        type: "time",
                        time: {
                            unit: "day"
                        },
                        title: {
                            display: true,
                            text: "Time"
                        }
                    },
                    y: {
                        title: {
                            display: true,
                            text: "Stat Value"
                        }
                    }
                }
            }
        });

        const name_mangler = new Object();
        name_mangler['counter'] = 0;

        name_mangler.unmangled_name = new Object();
        name_mangler.mangled_name = new Object();

        let ordinal_suffix = function(num) {
            let str = num.toString();
            let tens_place = '0';
            let ones_place = str[str.length-1];

            if (str.length >= 2) {
                tens_place = str[str.length-2];
            }

            if (tens_place === '1') {
                return 'th';
            }
            else {
                switch (ones_place) {
                    case '0':
                    case '4':
                    case '5':
                    case '6':
                    case '7':
                    case '8':
                    case '9':
                        return 'th';
                    case '1':
                        return 'st';
                    case '2':
                        return 'nd';
                    case '3':
                        return 'rd';
                }
            }
        };

        name_mangler.mangle = name => {
            if (name_mangler.mangled_name[name] === undefined) {
                if (name === 'Bryce Malary') {
                    name_mangler.mangled_name[name] = 'Naser Al Mighty';
                }

                else {
                    name_mangler.counter++;
                    name_mangler.mangled_name[name] = 'Jesse Doe the ' + name_mangler.counter + ordinal_suffix(name_mangler.counter); 
                }

                name_mangler.unmangled_name[name_mangler.mangled_name[name]] = name;
            }

            return name_mangler.mangled_name[name];
        };

        name_mangler.unmangle = name => {
            if (name_mangler.unmangled_name[name] === undefined) {
                console.error('ERROR, CAN\'T UNMANGLE ' + name);
            }

            return name_mangler.unmangled_name[name];
        };
        
        if (userType !== "athlete") {
            // Populate the team dropdown on page load
            if (userType !== "coach") {
                const teamDropdown = document.getElementById("teamSelect");
                for (const [key, value] of Object.entries(athleteData)) {
                    const option = document.createElement("option");
                    option.value = key;
                    option.textContent = key;
                    teamDropdown.appendChild(option);
                }

                // Event handler when team is selected
                teamDropdown.addEventListener("change", () => {
                    const team = teamDropdown.value;
                    athleteSelect.innerHTML = '<option value="">Select Athlete</option>';
                    athleteSelect.value = "";
                    statSelect.value = "";
                    clearChart();
                    if (team) {
                        for (const athlete of athleteData[team]) {
                            const option = document.createElement("option");

                            
                            if (PRESENTATION_MODE) {
                                option.textContent = name_mangler.mangle(athlete);
                            }

                            else {
                                option.textContent = athlete;
                            }

                            athleteSelect.appendChild(option);
                        }
                    }
                });
            } else {
                //add an option to view the entire team
                const option = document.createElement("option");
                option.textContent = "All Athletes";
                athleteSelect.appendChild(option);

                // Populate the athlete dropdown on page load
                for (const athlete of athleteData) {
                    //check if an option already exists
                    if (athleteSelect.innerHTML === '') {

                        const option = document.createElement("option");

                        if (PRESENTATION_MODE) {
                            option.textContent = name_mangler.mangle(athlete);
                        }

                        else{
                            option.textContent = athlete;
                        }

                        athleteSelect.appendChild(option);
                    }
                }
            } 

            athleteSelect.addEventListener("change", () => {
                let athlete = name_mangler.unmangle(athleteSelect.value);
                statSelect.value = "";
                clearChart();
                athlete = athlete.replace(/ /g, "-");
                fetch(`/get_athlete_data/${athlete}`)
                    .then(response => response.json())
                    .then(data => {
                        selectedAthleteData = data;
                        loadStatOptions(data);
                        getMinMaxTimestamp();
                        updateChart("null");
                        getMinMaxTimestamp();
                    });
            });
        } else {
            selectedAthleteData = athleteData;
            loadStatOptions(athleteData);
            getMinMaxTimestamp();
            updateChart("null");
            getMinMaxTimestamp();
        }

        // Function to calculate polynomial regression
        function polynomialRegression(x, y, order) {
            // Create the X matrix
            const xMatrix = [];
            for (let i = 0; i < x.length; i++) {
                const row = [];
                for (let j = 0; j <= order; j++) {
                    row.push(Math.pow(x[i], j));
                }
                xMatrix.push(row);
            }

            // Convert arrays to math.js matrices
            const X = math.matrix(xMatrix);
            const Y = math.matrix(y.map(v => [v]));

            // Compute (Xt * X)⁻¹ * Xt * Y to get the coefficients
            const Xt = math.transpose(X);
            const XtX = math.multiply(Xt, X);
            const XtX_inv = math.inv(XtX);
            const XtY = math.multiply(Xt, Y);
            const coefficients = math.multiply(XtX_inv, XtY);

            // Convert to an array for easier access
            const coefficientsArray = coefficients.toArray();

            // Create a predict function based on the calculated coefficients
            return {
                predict: (xVal) => {
                    let yVal = 0;
                    for (let i = 0; i < coefficientsArray.length; i++) {
                        yVal += coefficientsArray[i][0] * Math.pow(xVal, i);
                    }
                    return yVal;
                }
            };
        }

        function generatePolynomialRegression(data, order, minTimestamp, maxTimestamp) {
            const x = data.map(point => point.x);
            const y = data.map(point => point.y);

            // Calculate the polynomial regression
            const regression = polynomialRegression(x, y, order);

            const regressionPoints = [];
            for (let timestamp = minTimestamp; timestamp <= maxTimestamp; timestamp += 86400000) {
                const xValue = (timestamp - minTimestamp) / 86400000; // Normalize x value to range [0, 1]
                const yValue = regression.predict(xValue);
                regressionPoints.push({
                    x: new Date(timestamp),
                    y: yValue
                });
            }
            return regressionPoints;
        }

        // Function to add or remove the regression line based on checkbox
        function toggleRegression(stat) {
            const checkbox = document.getElementById("toggleRegression");
            const regressionDatasetIndex = statChart.data.datasets.findIndex(ds => ds.label.includes("Regression Line"));
            const minTimestamp = statChart.data.datasets[0].data[0].x.getTime();
            const maxTimestamp = statChart.data.datasets[0].data[statChart.data.datasets[0].data.length - 1].x.getTime();

            if (checkbox.checked) {
                //check if regression line already exists then remove it
                if (regressionDatasetIndex !== -1) {
                    statChart.data.datasets.splice(regressionDatasetIndex, 1);
                }

                const data = statChart.data.datasets[0].data;
                const cleanedData = [];
                for (let i = 0; i < data.length; i++) {
                    if (data[i].y !== null) {
                        cleanedData.push({
                            x: (data[i].x.getTime() - minTimestamp) / 86400000, // Normalize x value to range [0, 1]
                            y: data[i].y
                        });
                    }
                }
                
                const regressionPoints = generatePolynomialRegression(cleanedData, 4, minTimestamp, maxTimestamp);
                
                // Add regression line as a new dataset
                statChart.data.datasets.push({
                    label: `${stat} Regression Line`,
                    data: regressionPoints,
                    type: 'line',
                    borderColor: 'red',
                    borderWidth: 2,
                    fill: false,
                    pointRadius: 0
                });
            } else if (!checkbox.checked && regressionDatasetIndex !== -1) {
                // Remove the regression line dataset if it exists
                statChart.data.datasets.splice(regressionDatasetIndex, 1);
            }

            statChart.update();
        }

        // Modify updateChart to call toggleRegression
        function updateChart(stat) {
            const startDate = new Date(document.getElementById("startDate").value).getTime();
            const endDate = new Date(document.getElementById("endDate").value).getTime();

            if (stat === "null") {
                stat = statChart.data.datasets[0].label;
            }

            const data = selectedAthleteData
                .filter(test => {
                    const testDate = test.timestamp * 1000;
                    return (!isNaN(startDate) ? testDate >= startDate : true) && 
                        (!isNaN(endDate) ? testDate <= endDate : true);
                })
                .map(test => ({
                    x: new Date(test.timestamp * 1000),
                    y: test[stat]
                }));

            if (data.length === 0) {
                alert("No data available for the selected date range.");
                return;
            }

            statChart.data.datasets[0].data = data;
            statChart.data.datasets[0].label = stat;
            statChart.update();

            // Toggle regression line based on checkbox state
            if (statSelect.value) {
                toggleRegression(stat);
            }
        }

        function clearChart() {
            statChart.data.datasets[0].data = [];
            statChart.data.datasets[0].label = "";
            statChart.data.datasets.splice(1);
            statChart.update();
        }

        // Event listener for stat selection
        statSelect.addEventListener("change", (event) => {
            const selectedStat = event.target.value;
            if (selectedStat) {
                updateChart(selectedStat);
            }
        });

        startDate.addEventListener("change", () => {
            if (statSelect.value) updateChart(statSelect.value);
        });

        endDate.addEventListener("change", () => {
            if (statSelect.value) updateChart(statSelect.value);
        });

        // Event listener for checkbox
        document.getElementById("toggleRegression").addEventListener("change", () => {
            if (statSelect.value) toggleRegression(statSelect.value);
        });

        document.querySelectorAll('.time-filter-buttons .btn').forEach(button => {
            button.addEventListener('click', () => {
                const timeRange = button.getAttribute('data-time');
                const endDate = new Date();
                let startDate;

                switch (timeRange) {
                    case 'week':
                        startDate = new Date();
                        startDate.setDate(endDate.getDate() - 7);
                        break;
                    case 'month':
                        startDate = new Date();
                        startDate.setMonth(endDate.getMonth() - 1);
                        break;
                    case 'year':
                        startDate = new Date();
                        startDate.setFullYear(endDate.getFullYear() - 1);
                        break;
                    case 'all':
                        startDate = new Date(selectedAthleteData[0].timestamp * 1000);
                        break;
                }

                // Set the date inputs (if you want to show them)
                if (startDate) {
                    document.getElementById('startDate').value = startDate.toISOString().split('T')[0];
                }
                document.getElementById('endDate').value = endDate.toISOString().split('T')[0];

                updateChart('null');
            });
        });

    </script>
{% endblock %}